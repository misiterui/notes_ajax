
### 1. 作用
- Asynchronous JavaScript and XML 异步JS和XML
- 作用：在网页不刷新的情况下，向网页发送HTTP请求，得到HTTP响应。

### 2. 应用
1. 网页搜索时，搜索框下的提示条目
2. 注册页面，检测用户名是否可用
3. 鼠标放在一级分类上显示二级分类页面
4. 网页滚动到底后，刷新新内容
5. ...

### 3. XML简介
- eXtensible Markup Language 可扩展标记语言
- 作用：
	- 传输数据
	- 存储数据
	- 配置文件
- 和HMTL区别：HTML中都是预定义标签，而XML中没有预定义标签，全都是自定义标签，用来表示一些数据。

### 4. HTTP 协议
- Hypertext Transfer Protocol 超文本传输协议
- 协议详细规定了浏览器和万维网服务器之间互相通信的规则
##### 4.1 请求报文
-  请求行
```http
[GET/POST/PUT/DELETE] [url] [HTTP版本]
POST /s?ie=utf-8 HTTP/1.1
```
-  请求头
```http
Host: tencent.com
Cookie: name=tencent
Content-type: application/x-www-form-urlencoded
User-Agent: chrome 83
```
-  空行
- 请求体
```http
username=admin&password=admin
```

##### 4.2 响应报文
- 响应行
```http
[HTTP版本] [响应状态码] [响应状态字符串]
HTTP/1.1 200 OK
```
- 响应头
```http
Content-Type: text/html;charset=utf-8
Content-length: 2048
Content-encoding: gzip
```
- 空行
- 响应体
```html
<html>
	<head></head>
	<body>
		<h1>TEST</h1>
	</body>
</html>
```

### 5. Node.js
在本地安装一个 [Node.js](https://nodejs.org/zh-cn/download/package-manager) 环境

### 6. AJAX优缺点
- ##### 优点
	1. 可以无需刷新页面与服务器端进行通信
	2. 可以根据用户事件来更新部分页面内容
- ##### 缺点
	1. 没有浏览历史，不能回退
	2. 存在跨域问题（同源）（例如：a.com 向 b.com发送AJAX请求是不可以的）（可用一些技术解决）
	3. SEO不友好（SEO：Search Engine Optimization，搜索引擎优化）

### 7. AJAX 请求的基本操作
##### 1. 创建对象
```javascript
const xhr = new XMLHttpRequest();
```

##### 2. 初始化：设置请求方法和url
```javascript
xhr.open('GET', 'http://127.0.0.1:8000/server');
```

##### 3. 发送
```js
xhr.send();
```

##### 4. 事件绑定：处理服务端返回的结果
```js
xhr.onreadystatechange = function(){
    // 4：服务端返回了所有的结果
    if (xhr.readyState === 4) {
        // 状态码20x都是正常返回
        if (xhr.status >= 200 && xhr.status < 300) {
            // 处理结果：响应行 响应头 空行 响应体
            console.log(xhr.status);
            console.log(xhr.statusText);
            console.log(xhr.getAllResponseHeaders());
            console.log(xhr.response);
            
            // 设置result的文本
            result.innerHTML = xhr.response;
        }
    }
}
```

`XMLHttpRequest` 对象的状态`readystate`是指在执行AJAX请求的过程中，对象所处的不同阶段。
`readyState`的值是一个整数，范围 0~4，每个值代表一个特定的状态：
- 0 (UNSET): 初始状态，尚未调用`open()`方法
- 1 (OPENED): 已经调用`open()`方法，尚未调用`send()`方法
	- 此状态下，可以通过设置请求的HTTP方法、URL以及可选的其他属性（如`withCredentials`）来配置请求头
	- 此状态下，可以通过`setRequestHeader()`方法来设置请求头
- 2 (HEADERS_RECEIVED): 已经调用`send()`方法，并且收到了HTTP响应头
	- 此状态下，响应的状态码、状态消息、响应头已经可用
	- 此状态通常用于检查响应的状态码和响应头是否符合预期
- 3 (LOADING): 正在下载响应体
	- 此状态下，响应体正在下载中，但可能还没有完全接收完毕
	- 如果响应体是分块接收的，那么在这个状态下可以开始处理部分数据
	- 通常在处理大文件或流媒体时会用到这个状态
- 4 (DONE): 响应接收完成
	- 此状态下，响应体已经完全接收，并且可以访问响应数据
	- 在上面代码中，当请求完成时，`onreadystatechange`事件处理函数会被触发，可以在这个函数中检查`readyState`是否等于4，并检查`status`属性来确定请求是否成功。
注意：
- **检查`status`很重要！** 因为即使`readyState`达到了4，如果`status`不是200或其他成功的状态码（200~299都算成功），那么请求仍然被视为失败。
- 每个阶段的变化都会触发`onreadystatechange`事件处理函数，因此要加判断，只能是`readyState===4`的时候才能让该函数内部的代码起作用。

##### 完整案例

**前端**
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AJAX GET request</title>
    <style>
        #result{
            width: 200px;
            height: 100px;
            border: solid 1px skyblue;
        }
    </style>
</head>
<body>
    <button>send request</button>
    <div id="result"></div>

    <script>
        const btn = document.getElementsByTagName('button')[0];
        const result = document.getElementById("result");
        btn.onclick = function() {
            // 1. 创建对象
            const xhr = new XMLHttpRequest();
            // 2. 初始化：设置请求方法和url
            xhr.open('GET', 'http://127.0.0.1:8000/server');
            // 3. 发送
            xhr.send();
            // 4. 事件绑定：处理服务端返回的结果
            // readystate 是xhr对象中的属性，表示状态 0 1 2 3 4
            xhr.onreadystatechange = function(){
                // 4：服务端返回了所有的结果
                if (xhr.readyState === 4) {
                    // 状态码20x都是正常返回
                    if (xhr.status >= 200 && xhr.status < 300) {
                        // 处理结果：响应行 响应头 空行 响应体
                        console.log(xhr.status);
                        console.log(xhr.statusText);
                        console.log(xhr.getAllResponseHeaders());
                        console.log(xhr.response);

                        // 设置result的文本
                        result.innerHTML = xhr.response;
                    }
                }
            }
        }
    </script>
</body>
</html>
```

**后端**：启服方法：node server.js
```js
/* server.js */

// 1. 引入express
const express = require('express');

// 2. 创建应用对象
const app = express();

// 3. 创建路由规则
// request 是对请求报文的封装
// reponse 是对响应报文的封装
app.get('/server', (request, response)=>{
    // 设置响应头: 设置允许跨域
    response.setHeader('Access-Control-Allow-Origin', '*');
    // 设置响应体
    response.send('HELLO AJAX');
});

// 4. 监听端口启动服务
app.listen(8000, ()=>{
    console.log("Server start, listening on 8000...");
});
```

### 8. AJAX设置请求参数
在第2步：初始化：设置请求方法和url 中，url中添加`?`+`Query键值对`，多个键值对用`&`连接
```js
xhr.open('GET', 'http://127.0.0.1:8000/server?a=100&b=200&c=300');
```


### 9. AJAX发送POST请求
##### 1. 创建对象
```js
const xhr = new XMLHttpRequest();
```

##### 2. 初始化，设置类型与URL
```js
xhr.open('POST', 'http://127.0.0.1:8000/server');
```

##### 3. 设置请求头（与GET请求不同之处）
```js
// 设置预定义字段
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); 
// 设置自定义字段，浏览器告警，需要后端代码加一句：response.setHeader('Access-Control-Allow-Headers', '*');
xhr.setRequestHeader('name', 'mystery');
```

##### 4. 发送
```js
// POST请求的参数设置成请求体，由send()函数发送
// 以下两种写法都可以
// xhr.send('a=100&b=200&c=300');
xhr.send('a:100&b:200&c:300');
```

##### 5. 事件绑定
```js
xhr.onreadystatechange = function() {
	if (xhr.readyState === 4 && xhr.status >= 200 && xhr.status < 300) {
		result.innerHTML = xhr.response;
    }
}
```

##### 完整代码
**前端**
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AJXA POST Request</title>
    <style>
        #result{
            width: 200px;
            height: 100px;
            border: solid 1px skyblue;
        }
    </style>
</head>
<body>
    <div id="result"></div>
    <script>
        // 1. 获取元素对象
        const result = document.getElementById("result");
  
        // 2. 绑定事件
        result.addEventListener("mouseover", function(){
            // 1. 创建对象
            const xhr = new XMLHttpRequest();

            // 2. 初始化 设置类型与URL
            xhr.open('POST', 'http://127.0.0.1:8000/server');

            // 3. 设置请求头
            xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); // 预定义字段
            xhr.setRequestHeader('name', 'mystery'); // 自定义字段，浏览器告警，需要后端代码加一句：response.setHeader('Access-Control-Allow-Headers', '*');

            // 4. 发送
            // POST请求的参数设置成请求体，由send()函数发送
            // 以下两种写法都可以
            // xhr.send('a=100&b=200&c=300');
            xhr.send('a:100&b:200&c:300');

            // 5. 事件绑定
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4 && xhr.status >= 200 && xhr.status < 300) {
                    result.innerHTML = xhr.response;
                }
            }
        });
    </script>
</body>
</html>
```
**后端**
```js
// 1. 引入express
const express = require('express');

// 2. 创建应用对象
const app = express();

// 3. 创建路由规则
// request 是对请求报文的封装
// reponse 是对响应报文的封装
app.post('/server', (request, response)=>{
    // 设置响应头: 允许跨域
    response.setHeader('Access-Control-Allow-Origin', '*');
    // 设置响应头：允许前端请求头中包含自定义字段
    response.setHeader('Access-Control-Allow-Headers', '*');
    // 设置响应体
    response.send('POST AJAX');
});

// 4. 监听端口启动服务
app.listen(8000, ()=>{
    console.log("Server start, listening on 8000...");
});
```


注意：由于在POST请求之前，浏览器会自动先发送一个OPTIONS请求（是一个作为跨域请求一部分的预检请求），服务端没有OPTIONS对应的响应方法，所以会报错。
![[01.OPTIONS请求.png]]
![[02.POST因OPTIONS报错.png]]

一个修改方法：后端的post方法改成all，使其支持所有类型的请求。
后端修改之后的代码：
```js
// 1. 引入express
const express = require('express');

// 2. 创建应用对象
const app = express();

// 3. 创建路由规则
// request 是对请求报文的封装
// reponse 是对响应报文的封装
app.all('/server', (request, response)=>{
    // 设置响应头: 允许跨域
    response.setHeader('Access-Control-Allow-Origin', '*');
    // 设置响应头：允许前端请求头中包含自定义字段
    response.setHeader('Access-Control-Allow-Headers', '*');
    // 设置响应体
    response.send('POST AJAX');
});

// 4. 监听端口启动服务
app.listen(8000, ()=>{
    console.log("Server start, listening on 8000...");
});
```

![[03.POST正常.png]]


### 10. AJAX 服务端响应JSON
##### 后端
```js
// 1. 引入express
const express = require('express');

// 2. 创建应用对象
const app = express();

// 3. 创建路由规则
// request 是对请求报文的封装
// reponse 是对响应报文的封装
app.all('/json-server', (request, response)=>{
    // 设置响应头: 允许跨域
    response.setHeader('Access-Control-Allow-Origin', '*');
    // 设置响应头：允许前端请求头中包含自定义字段
    response.setHeader('Access-Control-Allow-Headers', '*');
    // 响应一个数据
    const data = {
        name: "mystery",
    };
    // 对对象进行字符串转换
    // let str = JSON.stringify(data); //新版已经支持直接发送结构体
    // 设置响应体
    response.send(data);
});

// 4. 监听端口启动服务
app.listen(8000, ()=>{
    console.log("Server start, listening on 8000...");
});
```
##### 前端
第一种方法：解析data
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AJXA POST Request</title>
    <style>
        #result{
            width: 200px;
            height: 100px;
            border: solid 1px skyblue;
        }
    </style>
</head>
<body>
    <div id="result"></div>
    <script>
        window.onkeydown = function() {
            const xhr = new XMLHttpRequest();
            xhr.open('GET', 'http://127.0.0.1:8000/json-server');
            xhr.send();
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4 && xhr.status >= 200 && xhr.status < 300) {
                    let data = JSON.parse(xhr.response);
                    result.innerHTML = data.name;
                }
            }
        }
    </script>
</body>
</html>
```
第二种方法：不解析data，直接用！
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AJXA POST Request</title>
    <style>
        #result{
            width: 200px;
            height: 100px;
            border: solid 1px skyblue;
        }
    </style>
</head>
<body>
    <div id="result"></div>
    <script>
        window.onkeydown = function() {
            const xhr = new XMLHttpRequest();
            xhr.responseType = 'json';
            xhr.open('GET', 'http://127.0.0.1:8000/json-server');
            xhr.send();
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4 && xhr.status >= 200 && xhr.status < 300) {
                    console.log(xhr.response);
                    result.innerHTML = xhr.response.name;
                }
            }
        }
    </script>
</body>
</html>
```


### 11. IE缓存问题解决
IE浏览器的缓存机制是：当从服务器获取过一次某个数据后，一段时间内，这个数据会存在ie的缓存中，用户想要再次获取该数据时，会优先使用缓存中的旧数据。如果服务器端数据已经更新过，此时数据便是错的，需要最新数据！！

以下是普通写法和针对IE缓存问题的写法对比：

普通写法：
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AJXA POST Request</title>
    <style>
        #result{
            width: 200px;
            height: 100px;
            border: solid 1px skyblue;
        }
    </style>
</head>
<body>
    <button>send request</button>
    <div id="result"></div>
    <script>
        const btn = document.getElementsByTagName('button')[0];
        const result = document.querySelector('#result');

        btn.addEventListener('click', function(){
            const xhr = new XMLHttpRequest();
            xhr.open('GET', 'http://127.0.0.1:8000/ie-cache');
            xhr.send();
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4 && xhr.status >= 200 && xhr.status < 300) {
                    result.innerHTML = xhr.response;
                }
            }
        })
    </script>
</body>
</html>
```

针对IE的写法：
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AJXA POST Request</title>
    <style>
        #result{
            width: 200px;
            height: 100px;
            border: solid 1px skyblue;
        }
    </style>
</head>
<body>
    <button>send request</button>
    <div id="result"></div>
    <script>
        const btn = document.getElementsByTagName('button')[0];
        const result = document.querySelector('#result');

        btn.addEventListener('click', function(){
            const xhr = new XMLHttpRequest();
            xhr.open('GET', 'http://127.0.0.1:8000/ie-cache?t='+Date.now());//增加时间戳，使IE浏览器认为这是两次不同的请求，因为URL每次都不一样
            xhr.send();
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4 && xhr.status >= 200 && xhr.status < 300) {
                    result.innerHTML = xhr.response;
                }
            }
        })
    </script>
</body>
</html>
```

后端：
```js
// 1. 引入express
const express = require('express');

// 2. 创建应用对象
const app = express();

// 3. 创建路由规则
// request 是对请求报文的封装
// reponse 是对响应报文的封装

app.all('/ie-cache', (request, response)=>{
    // 设置响应头: 允许跨域
    response.setHeader('Access-Control-Allow-Origin', '*');
    // 设置响应体
    response.send("IE-CACHE - 1");
});

// 4. 监听端口启动服务
app.listen(8000, ()=>{
    console.log("Server start, listening on 8000...");
});
```

### 12. AJAX请求的各种异常状态

##### 1. 请求超时
前端
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AJXA POST Request</title>
    <style>
        #result{
            width: 200px;
            height: 100px;
            border: solid 1px skyblue;
        }
    </style>
</head>
<body>
    <button>send request</button>
    <div id="result"></div>
    <script>
        const btn = document.getElementsByTagName('button')[0];
        const result = document.querySelector('#result');
        btn.addEventListener('click', function(){
            const xhr = new XMLHttpRequest();
            // 超时设置
            xhr.timeout = 2000;
            // 超时回调
            xhr.ontimeout = function() {
                alert("网络异常，请稍后重试！");
            }
            xhr.open("GET", 'http://127.0.0.1:8000/response-delay');
            xhr.send();
            xhr.onreadystatechange = function(){
                if (xhr.readyState === 4 && xhr.status >= 200 && xhr.status < 300) {
                    result.innerHTML = xhr.response;
                }
            }
        })
    </script>
</body>
</html>
```

后端
```js
// 1. 引入express
const express = require('express');

// 2. 创建应用对象
const app = express();  

// 3. 创建路由规则
// request 是对请求报文的封装
// reponse 是对响应报文的封装

// 延时响应
app.all('/response-delay', (request, response)=>{
    // 设置响应头: 允许跨域
    response.setHeader('Access-Control-Allow-Origin', '*');
    setTimeout(()=>{
        // 设置响应体
        response.send("response delay");
    }, 3000);
});

// 4. 监听端口启动服务
app.listen(8000, ()=>{
    console.log("Server start, listening on 8000...");
});
```

![[04.请求超时.png]]
##### 2. 网络异常
前端
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AJXA POST Request</title>
    <style>
        #result{
            width: 200px;
            height: 100px;
            border: solid 1px skyblue;
        }
    </style>
</head>
<body>
    <button>send request</button>
    <div id="result"></div>
    <script>
        const btn = document.getElementsByTagName('button')[0];
        const result = document.querySelector('#result');
        btn.addEventListener('click', function(){
            const xhr = new XMLHttpRequest();
            // 网络异常回调
            xhr.onerror = function() {
                alert("network error!");
            }
            xhr.open("GET", 'http://127.0.0.1:8000/response-delay');
            xhr.send();
            xhr.onreadystatechange = function(){
                if (xhr.readyState === 4 && xhr.status >= 200 && xhr.status < 300) {
                    result.innerHTML = xhr.response;
                }
            }
        })
    </script>
</body>
</html>
```
测试方法：Chrome浏览器断网方法
![[05.Chrome浏览器断网方法.png]]
##### 3. 取消请求
前端
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AJXA POST Request</title>
    <style>
        #result{
            width: 200px;
            height: 100px;
            border: solid 1px skyblue;
        }
    </style>
</head>
<body>
    <button>send request</button>
    <button>cancel request</button>
    <div id="result"></div>
    <script>
        const btns = document.getElementsByTagName('button');
        const result = document.querySelector('#result');
  
        let xhr = new XMLHttpRequest();

        // 发送请求
        btns[0].onclick = function() {
            xhr.open("GET", 'http://127.0.0.1:8000/response-delay');
            xhr.send();
        }
        // 取消请求
        btns[1].onclick = function() {
            xhr.abort();
        }
    </script>
</body>
</html>
```

##### 4. 请求重复发送
前端
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>repeat request</title>
    <style>
        #result{
            width: 200px;
            height: 100px;
            border: solid 1px skyblue;
        }
    </style>
</head>
<body>
    <button>send request</button>
    <div id="result"></div>
    <script>
        const btns = document.getElementsByTagName('button');
        const result = document.querySelector('#result');
  
        let xhr = null;
        let isSending = false;
        
        // 发送请求
        btns[0].onclick = function() {
            if (isSending) xhr.abort();
            xhr = new XMLHttpRequest();
            isSending = true;
            xhr.open("GET", 'http://127.0.0.1:8000/response-delay');
            xhr.send();
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                    isSending = false;
                }
            }
        }
    </script>
</body>
</html>
```
### 13. jQuery中的AJAX

##### get请求
```jQuery
$.get(url, [data], [callback], [type])
```
- `url` 请求的网址
- `data` 请求携带的参数
- `callback` 载入成功时的回调函数
- `type` 设置返回内容格式，xml, html, script, json, text, default （该参数可省略不写）
##### post请求
```jQuery
$.post(url, [data], [callback], [type])
```
- `url` 请求的URL地址
- `data` 请求携带的参数
- `callback` 载入成功时回调函数
- `type` 设置返回内容格式，xml, html, script, json, text, default（该参数可省略不写）
##### AJAX请求
```jQuery
$.ajax({
    // url
    url: 'http://127.0.0.1:8000/jquery-server',
    // 参数
    data: {a: 100, b: 200},
    // 请求类型
    type: 'GET',
    // 成功的回调
    dataType:'json',
    success: function(data){
        console.log(data);
    },
    timeout: 2000,
    // 失败的回调
    error: function() {
        console.log('error');
    },
    // 头信息
    headers: {
        c: 300,
        d: 400
    }
});
```

前端：
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>jQuery send AJAX request</title>
    <script src="jquery-3.7.1.min.js"></script>
</head>
<body>
    <button>GET</button>
    <button>POST</button>
    <button>AJAX</button>
    <script>
        $('button').eq(0).click(function(){
            $.get('http://127.0.0.1:8000/jquery-server', {a:100, b:200}, function(data) { // data是响应体
                console.log(data);
            })
        });
  
        $('button').eq(1).click(function(){
            $.post('http://127.0.0.1:8000/jquery-server', {a:100, b:200}, function(data) {
                console.log(data);
            })
        });
  
        $('button').eq(2).click(function(){
            $.ajax({
                // url
                url: 'http://127.0.0.1:8000/jquery-server',
                // 参数
                data: {a: 100, b: 200},
                // 请求类型
                type: 'GET',
                // 成功的回调
                dataType:'json',
                success: function(data){
                    console.log(data);
                },
                timeout: 2000,
                // 失败的回调
                error: function() {
                    console.log('error');
                },
                // 头信息
                headers: {
                    c: 300,
                    d: 400
                }
            });
        });
    </script>
</body>
</html>
```

后端：
```js
// 1. 引入express
const express = require('express');

// 2. 创建应用对象
const app = express();

// 3. 创建路由规则
// request 是对请求报文的封装
// reponse 是对响应报文的封装

// 延时响应
app.all('/response-delay', (request, response)=>{
    // 设置响应头: 允许跨域
    response.setHeader('Access-Control-Allow-Origin', '*');
    setTimeout(()=>{
        // 设置响应体
        response.send("response delay");
    }, 3000);
});

// jQuery 服务
app.all('/jquery-server', (request, response) => {
    // 设置响应头：允许跨域
    response.setHeader('Access-Control-Allow-Origin', '*');
    // 设置响应头：允许前端请求头中包含自定义字段
    response.setHeader('Access-Control-Allow-Headers', '*');
    // response.send('jQuery AJAX');
    const data = {name: "mystery"};
    console.log(data);
    response.send(data);
});

// 4. 监听端口启动服务
app.listen(8000, ()=>{
    console.log("Server start, listening on 8000...");
});
```

### 14. axios发送AJAX请求
前端
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Axio send AJAX request</title>
    <script src="https://cdn.jsdelivr.net/npm/axios@1.6.7/dist/axios.min.js"></script>
</head>
<body>
    <button>GET</button>
    <button>POST</button>
    <button>AJAX</button>
    <script>
        const btns = document.querySelectorAll('button');
        // 配置baseURL
        axios.defaults.baseURL = 'http://127.0.0.1:8000';
        // GET
        btns[0].onclick = function() {
            axios.get('/axios-server', {
                // url参数
                params: {
                    id: 100,
                    vip: 7
                },
                headers: {
                    name: "mystery",
                    age: 18
                }
            }).then(value => {
                console.log(value);
            });
        }

        btns[1].onclick = function() {
            axios.post('/axios-server', {
                    username: 'admin',
                    password: 'admin',
                }, {
                // 请求行
                params: {
                    id: 200,
                    vip: 9,
                },
                // 请求头参数
                headers: {
                    height:180,
                    weight:180,
                },
            })
        }
  
        btns[2].onclick = function() {
            axios({
                // 请求方法
                method: 'POST',
                // url
                url: '/axios-server',
                // url 参数
                params: {
                    vip: 10,
                    level: 30
                },
                // 头信息
                headers: {
                    a: 100,
                    b: 200
                },
                // 请求体参数
                data: {
                    username: 'admin',
                    password: 'admin',
                },
            }).then(response=>{
                console.log(response);
                console.log(response.status);
                console.log(response.statusText);
                console.log(response.headers);
                console.log(response.data);
            })
        }
    </script>
</body>
</html>
```

后端
```js
// 1. 引入express
const express = require('express');

// 2. 创建应用对象
const app = express();

// 3. 创建路由规则
// request 是对请求报文的封装
// reponse 是对响应报文的封装

// axios 服务
app.all('/axios-server', (request, response) => {
    // 设置响应头：允许跨域
    response.setHeader('Access-Control-Allow-Origin', '*');
    // 设置响应头：允许前端请求头中包含自定义字段
    response.setHeader('Access-Control-Allow-Headers', '*');
    const data = {name: "mystery"};
    response.send(data);
});

// 4. 监听端口启动服务
app.listen(8000, ()=>{
    console.log("Server start, listening on 8000...");
});
```


### 15. fetch()函数发送AJAX请求
```js
fetch([resource], [options(可选)]);
```

- `resource` 定义要获取的资源。资源可能是：
	- 一个`USVString`字符串，包含要获取资源的URL。一些浏览器会接受`blob:`和`data:`作为schemes
	- 一个`Request`对象
- `options` 一个配置项对象，包括所有对请求的设置。可选参数有：
	- `method`：请求使用的方法，例如`GET` `POST`
	- `headers`：请求的头信息，形式为`Headers`的对象或包含`ByteString`值的对象字面量。
	- `body`：请求的body信息：可能是一个`Blob`、`BufferSource`、`FormData`、`URLSearchParams`或者`USVString`对象。注意`GET`和`HEAD`方法的请求不能包含body信息。
	- `mode`：请求的模式，例如：`cors`、`no-cors`、`same-origin`
	- ...

前端
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>fetch send AJAX request</title>
</head>
<body>
    <button>AJAX</button>
    <script>
        const btn = document.querySelector('button');
        btn.onclick = function() {
            fetch('http://127.0.0.1:8000/fetch-server?vip=10', {
                // 请求方法
                method: 'POST',
                // 请求头
                headers: {
                    name: 'mystery',
                },
                body: 'username=admin&password=admin',
            }).then(response => {
                return response.text();
            }).then(response => {
                console.log(response);
            });
        }
    </script>
</body>
</html>
```

后端
```js
// 1. 引入express
const express = require('express');

// 2. 创建应用对象
const app = express();

// 3. 创建路由规则
// request 是对请求报文的封装
// reponse 是对响应报文的封装

// fetch 服务
app.all('/fetch-server', (request, response) => {
    // 设置响应头：允许跨域
    response.setHeader('Access-Control-Allow-Origin', '*');
    // 设置响应头：允许前端请求头中包含自定义字段
    response.setHeader('Access-Control-Allow-Headers', '*');
    const data = {name: "mystery"};
    response.send(data);
});

// 4. 监听端口启动服务
app.listen(8000, ()=>{
    console.log("Server start, listening on 8000...");
});
```


### 16. 跨域
##### 1. 同源策略
- 浏览器的一种安全策略
- 同源：协议、域名、端口号 必须完全相同
- 违背同源策略就是跨域
- AJAX默认遵循同源策略，不满足同源策略无法**直接**发送AJAX请求

**同源请求&发送网页**
前端
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>index</title>
</head>
<body>
    <h1>test</h1>
    <button>click to get user data</button>

    <script>
        const btn = document.querySelector('button');
        btn.onclick = function() {
            const xhr = new XMLHttpRequest();
            // 这里因为是满足同源策略的，所以url可以简写
            xhr.open("GET", '/data');
            // 发送
            xhr.send();
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4 && xhr.status >= 200 && xhr.status < 300) {
                    console.log(xhr.response);
                }
            }
        }
    </script>
</body>
</html>
```

后端
```js
const express = require('express');
const app = express();

app.get('/home', (request, response) => {
    // 响应一个页面
    response.sendFile(__dirname + '/index.html');
});

app.get('/data', (request, response) => {
    response.send('user data');
});

app.listen(9000, () => {
    console.log("server start on 9000 ...");
});
```

##### 2. 如何解决跨域
###### 2.1 JSONP
- JSON with Padding，是一个非官方的跨域解决方案，纯粹靠程序员的聪明才智开发出来，只支持get请求。
- JSONP怎么工作的？
	- HTML中有一些标签天生具有跨域能力，比如：img link iframe script
	- JSONP就是利用script标签的跨域能力来发送请求的
- JSONP 的使用
	- 方法一
		前端
	```html
	<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>jsonp</title>
    <style>
        #result{
            width: 200px;
            height: 100px;
            border: solid 1px skyblue;
        }
    </style>
</head>
<body>
    <div id="result"></div>

    <script src="./app.js">
    
    </script>
</body>
</html>
```

后端
```js
const data = {
    name: 'mystery',
};

console.log(data);
  
// 处理数据
function handle(data) {
    // 获取result元素
    const result = document.getElementById('result');
    result.innerHTML = data.name;
}
handle(data);
```

方法二
前端
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>jsonp</title>
    <style>
        #result{
            width: 200px;
            height: 100px;
            border: solid 1px skyblue;
        }
    </style>
</head>
<body>
    <div id="result"></div>

    <script>
        // 处理数据
        function handle(data) {
            // 获取result元素
            const result = document.getElementById('result');
            result.innerHTML = data.name;
        }
    </script>
    <script src="./app.js"></script>
</body>
</html>
```

后端
```js
const data = {
    name: 'mystery',
};

console.log(data);
handle(data);
```

- `script`标签发送的请求要求返回值必须是js代码

案例：用户在输入框的焦点消失，提示用户该名字是否存在
前端：
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>case</title>
</head>
<body>
    username: <input type="text" id="username">
    <p></p>
    <script>
        // 获取input元素
        const input = document.querySelector('input');
        const p = document.querySelector('p');

        // 声明handle函数
        function handle(data) {
            input.style.border = "solid 1px skyblue";
            // 修改p标签的提示文本
            p.innerHTML = data.msg;

        }
        // 绑定事件
        input.onblur = function() {
            // 获取用户的输入值
            let username = this.value;
            // 向服务端发送请求 检测用户名是否存在
            // 1. 创建script标签
            const script = document.createElement('script');
            // 2. 设置script标签的src属性
            script.src = 'http://127.0.0.1:9001/jsonp-server';
            // 3. 将script插入到文档中
            document.body.appendChild(script);
        }
    </script>
</body>
</html>
```

后端
```js
const express = require('express');

const app = express();

app.all('/jsonp-server', (request, response) => {
    const data = {
        exists: 1,
        msg: 'username exists',
    };
    // 将data对象转为字符串
    let str = JSON.stringify(data);
    // 返回结果
    response.end(`handle(${str})`);

});

app.listen(9001, () => {
    console.log("server start on 9001 ...");
})
```

jQuery发送JSONP请求
前端
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>jQuery</title>
    <style>
        #result{
            width: 200px;
            height: 100px;
            border: solid 1px skyblue;
        }
    </style>
    <!-- 引入jQuery -->
    <script src="./jquery-3.7.1.min.js"></script>
</head>
<body>
    <button>send jsonp request</button>
    <div id="result"></div>
    <script>
        $('button').eq(0).click(function(){
            $.getJSON('http://127.0.0.1:9001/jquery-jsonp-server?callback=?', function(data){
                console.log(data);
            });
        });
    </script>
</body>
</html>
```

后端
```js
const express = require('express');
const app = express();
app.all('/jquery-jsonp-server', (request, response) => {
    const data = {
        name: "mystery",
        skill: ["javascript", "css3", "html5", "jquery", "nodejs", "ajax"],
    };
    let str = JSON.stringify(data);
    // 接收callback参数
    let cb = request.query.callback;
    // 返回结果
    response.end(`${cb}(${str})`);
});

app.listen(9001, () => {
    console.log("server start on 9001 ...");
});
```


###### 2.2 CORS
1. 定义：Cross-Origin Resource Sharing, 跨域资源共享。CORS是官方的跨域解决方案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持get和post请求。跨域资源共享标准新增了一组HTTP首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源
2. CORS怎么工作的？CORS是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应以后会对响应放行。
3. 用法：`response.setHeader('Access-Control-Allow-Origin', '*');`
	1. 第二个参数：允许的网页的url，例如：`127.0.0.1:5000`
