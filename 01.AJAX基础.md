
### 1. 作用
- Asynchronous JavaScript and XML 异步JS和XML
- 作用：在网页不刷新的情况下，向网页发送HTTP请求，得到HTTP响应。

### 2. 应用
1. 网页搜索时，搜索框下的提示条目
2. 注册页面，检测用户名是否可用
3. 鼠标放在一级分类上显示二级分类页面
4. 网页滚动到底后，刷新新内容
5. ...

### 3. XML简介
- eXtensible Markup Language 可扩展标记语言
- 作用：
	- 传输数据
	- 存储数据
	- 配置文件
- 和HMTL区别：HTML中都是预定义标签，而XML中没有预定义标签，全都是自定义标签，用来表示一些数据。

### 4. HTTP 协议
- Hypertext Transfer Protocol 超文本传输协议
- 协议详细规定了浏览器和万维网服务器之间互相通信的规则
##### 4.1 请求报文
-  请求行
```http
[GET/POST/PUT/DELETE] [url] [HTTP版本]
POST /s?ie=utf-8 HTTP/1.1
```
-  请求头
```http
Host: tencent.com
Cookie: name=tencent
Content-type: application/x-www-form-urlencoded
User-Agent: chrome 83
```
-  空行
- 请求体
```http
username=admin&password=admin
```

##### 4.2 响应报文
- 响应行
```http
[HTTP版本] [响应状态码] [响应状态字符串]
HTTP/1.1 200 OK
```
- 响应头
```http
Content-Type: text/html;charset=utf-8
Content-length: 2048
Content-encoding: gzip
```
- 空行
- 响应体
```html
<html>
	<head></head>
	<body>
		<h1>TEST</h1>
	</body>
</html>
```

### 5. Node.js
在本地安装一个 [Node.js](https://nodejs.org/zh-cn/download/package-manager) 环境

### 6. AJAX优缺点
- ##### 优点
	1. 可以无需刷新页面与服务器端进行通信
	2. 可以根据用户事件来更新部分页面内容
- ##### 缺点
	1. 没有浏览历史，不能回退
	2. 存在跨域问题（同源）（例如：a.com 向 b.com发送AJAX请求是不可以的）（可用一些技术解决）
	3. SEO不友好（SEO：Search Engine Optimization，搜索引擎优化）

### 7. AJAX 请求的基本操作
##### 1. 创建对象
```javascript
const xhr = new XMLHttpRequest();
```

##### 2. 初始化：设置请求方法和url
```javascript
xhr.open('GET', 'http://127.0.0.1:8000/server');
```

##### 3. 发送
```js
xhr.send();
```

##### 4. 事件绑定：处理服务端返回的结果
```js
xhr.onreadystatechange = function(){
    // 4：服务端返回了所有的结果
    if (xhr.readyState === 4) {
        // 状态码20x都是正常返回
        if (xhr.status >= 200 && xhr.status < 300) {
            // 处理结果：响应行 响应头 空行 响应体
            console.log(xhr.status);
            console.log(xhr.statusText);
            console.log(xhr.getAllResponseHeaders());
            console.log(xhr.response);
            
            // 设置result的文本
            result.innerHTML = xhr.response;
        }
    }
}
```

`XMLHttpRequest` 对象的状态`readystate`是指在执行AJAX请求的过程中，对象所处的不同阶段。
`readyState`的值是一个整数，范围 0~4，每个值代表一个特定的状态：
- 0 (UNSET): 初始状态，尚未调用`open()`方法
- 1 (OPENED): 已经调用`open()`方法，尚未调用`send()`方法
	- 此状态下，可以通过设置请求的HTTP方法、URL以及可选的其他属性（如`withCredentials`）来配置请求头
	- 此状态下，可以通过`setRequestHeader()`方法来设置请求头
- 2 (HEADERS_RECEIVED): 已经调用`send()`方法，并且收到了HTTP响应头
	- 此状态下，响应的状态码、状态消息、响应头已经可用
	- 此状态通常用于检查响应的状态码和响应头是否符合预期
- 3 (LOADING): 正在下载响应体
	- 此状态下，响应体正在下载中，但可能还没有完全接收完毕
	- 如果响应体是分块接收的，那么在这个状态下可以开始处理部分数据
	- 通常在处理大文件或流媒体时会用到这个状态
- 4 (DONE): 响应接收完成
	- 此状态下，响应体已经完全接收，并且可以访问响应数据
	- 在上面代码中，当请求完成时，`onreadystatechange`事件处理函数会被触发，可以在这个函数中检查`readyState`是否等于4，并检查`status`属性来确定请求是否成功。
注意：
- **检查`status`很重要！** 因为即使`readyState`达到了4，如果`status`不是200或其他成功的状态码（200~299都算成功），那么请求仍然被视为失败。
- 每个阶段的变化都会触发`onreadystatechange`事件处理函数，因此要加判断，只能是`readyState===4`的时候才能让该函数内部的代码起作用。

##### 完整案例

**前端**
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AJAX GET request</title>
    <style>
        #result{
            width: 200px;
            height: 100px;
            border: solid 1px skyblue;
        }
    </style>
</head>
<body>
    <button>send request</button>
    <div id="result"></div>

    <script>
        const btn = document.getElementsByTagName('button')[0];
        const result = document.getElementById("result");
        btn.onclick = function() {
            // 1. 创建对象
            const xhr = new XMLHttpRequest();
            // 2. 初始化：设置请求方法和url
            xhr.open('GET', 'http://127.0.0.1:8000/server');
            // 3. 发送
            xhr.send();
            // 4. 事件绑定：处理服务端返回的结果
            // readystate 是xhr对象中的属性，表示状态 0 1 2 3 4
            xhr.onreadystatechange = function(){
                // 4：服务端返回了所有的结果
                if (xhr.readyState === 4) {
                    // 状态码20x都是正常返回
                    if (xhr.status >= 200 && xhr.status < 300) {
                        // 处理结果：响应行 响应头 空行 响应体
                        console.log(xhr.status);
                        console.log(xhr.statusText);
                        console.log(xhr.getAllResponseHeaders());
                        console.log(xhr.response);

                        // 设置result的文本
                        result.innerHTML = xhr.response;
                    }
                }
            }
        }
    </script>
</body>
</html>
```

**后端**：启服方法：node server.js
```js
/* server.js */

// 1. 引入express
const express = require('express');

// 2. 创建应用对象
const app = express();

// 3. 创建路由规则
// request 是对请求报文的封装
// reponse 是对响应报文的封装
app.get('/server', (request, response)=>{
    // 设置响应头: 设置允许跨域
    response.setHeader('Access-Control-Allow-Origin', '*');
    // 设置响应体
    response.send('HELLO AJAX');
});

// 4. 监听端口启动服务
app.listen(8000, ()=>{
    console.log("Server start, listening on 8000...");
});
```

### 8. AJAX设置请求参数
在第2步：初始化：设置请求方法和url 中，url中添加`?`+`Query键值对`，多个键值对用`&`连接
```js
xhr.open('GET', 'http://127.0.0.1:8000/server?a=100&b=200&c=300');
```


### 9. AJAX发送POST请求
##### 1. 创建对象
```js
const xhr = new XMLHttpRequest();
```

##### 2. 初始化，设置类型与URL
```js
xhr.open('POST', 'http://127.0.0.1:8000/server');
```

##### 3. 设置请求头（与GET请求不同之处）
```js
// 设置预定义字段
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); 
// 设置自定义字段，浏览器告警，需要后端代码加一句：response.setHeader('Access-Control-Allow-Headers', '*');
xhr.setRequestHeader('name', 'mystery');
```

##### 4. 发送
```js
// POST请求的参数设置成请求体，由send()函数发送
// 以下两种写法都可以
// xhr.send('a=100&b=200&c=300');
xhr.send('a:100&b:200&c:300');
```

##### 5. 事件绑定
```js
xhr.onreadystatechange = function() {
	if (xhr.readyState === 4 && xhr.status >= 200 && xhr.status < 300) {
		result.innerHTML = xhr.response;
    }
}
```

##### 完整代码
**前端**
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AJXA POST Request</title>
    <style>
        #result{
            width: 200px;
            height: 100px;
            border: solid 1px skyblue;
        }
    </style>
</head>
<body>
    <div id="result"></div>
    <script>
        // 1. 获取元素对象
        const result = document.getElementById("result");
  
        // 2. 绑定事件
        result.addEventListener("mouseover", function(){
            // 1. 创建对象
            const xhr = new XMLHttpRequest();

            // 2. 初始化 设置类型与URL
            xhr.open('POST', 'http://127.0.0.1:8000/server');

            // 3. 设置请求头
            xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); // 预定义字段
            xhr.setRequestHeader('name', 'mystery'); // 自定义字段，浏览器告警，需要后端代码加一句：response.setHeader('Access-Control-Allow-Headers', '*');

            // 4. 发送
            // POST请求的参数设置成请求体，由send()函数发送
            // 以下两种写法都可以
            // xhr.send('a=100&b=200&c=300');
            xhr.send('a:100&b:200&c:300');

            // 5. 事件绑定
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4 && xhr.status >= 200 && xhr.status < 300) {
                    result.innerHTML = xhr.response;
                }
            }
        });
    </script>
</body>
</html>
```
**后端**
```js
// 1. 引入express
const express = require('express');

// 2. 创建应用对象
const app = express();

// 3. 创建路由规则
// request 是对请求报文的封装
// reponse 是对响应报文的封装
app.post('/server', (request, response)=>{
    // 设置响应头: 允许跨域
    response.setHeader('Access-Control-Allow-Origin', '*');
    // 设置响应头：允许前端请求头中包含自定义字段
    response.setHeader('Access-Control-Allow-Headers', '*');
    // 设置响应体
    response.send('POST AJAX');
});

// 4. 监听端口启动服务
app.listen(8000, ()=>{
    console.log("Server start, listening on 8000...");
});
```


注意：由于在POST请求之前，浏览器会自动先发送一个OPTIONS请求（是一个作为跨域请求一部分的预检请求），服务端没有OPTIONS对应的响应方法，所以会报错。
![[01.OPTIONS请求.png]]
![[02.POST因OPTIONS报错.png]]

一个修改方法：后端的post方法改成all，使其支持所有类型的请求。
后端修改之后的代码：
```js
// 1. 引入express
const express = require('express');

// 2. 创建应用对象
const app = express();

// 3. 创建路由规则
// request 是对请求报文的封装
// reponse 是对响应报文的封装
app.all('/server', (request, response)=>{
    // 设置响应头: 允许跨域
    response.setHeader('Access-Control-Allow-Origin', '*');
    // 设置响应头：允许前端请求头中包含自定义字段
    response.setHeader('Access-Control-Allow-Headers', '*');
    // 设置响应体
    response.send('POST AJAX');
});

// 4. 监听端口启动服务
app.listen(8000, ()=>{
    console.log("Server start, listening on 8000...");
});
```

![[03.POST正常.png]]


### 10. AJAX 服务端响应JSON
##### 后端
```js
// 1. 引入express
const express = require('express');

// 2. 创建应用对象
const app = express();

// 3. 创建路由规则
// request 是对请求报文的封装
// reponse 是对响应报文的封装
app.all('/json-server', (request, response)=>{
    // 设置响应头: 允许跨域
    response.setHeader('Access-Control-Allow-Origin', '*');
    // 设置响应头：允许前端请求头中包含自定义字段
    response.setHeader('Access-Control-Allow-Headers', '*');
    // 响应一个数据
    const data = {
        name: "mystery",
    };
    // 对对象进行字符串转换
    // let str = JSON.stringify(data); //新版已经支持直接发送结构体
    // 设置响应体
    response.send(data);
});

// 4. 监听端口启动服务
app.listen(8000, ()=>{
    console.log("Server start, listening on 8000...");
});
```
##### 前端
第一种方法：解析data
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AJXA POST Request</title>
    <style>
        #result{
            width: 200px;
            height: 100px;
            border: solid 1px skyblue;
        }
    </style>
</head>
<body>
    <div id="result"></div>
    <script>
        window.onkeydown = function() {
            const xhr = new XMLHttpRequest();
            xhr.open('GET', 'http://127.0.0.1:8000/json-server');
            xhr.send();
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4 && xhr.status >= 200 && xhr.status < 300) {
                    let data = JSON.parse(xhr.response);
                    result.innerHTML = data.name;
                }
            }
        }
    </script>
</body>
</html>
```
第二种方法：不解析data，直接用！
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AJXA POST Request</title>
    <style>
        #result{
            width: 200px;
            height: 100px;
            border: solid 1px skyblue;
        }
    </style>
</head>
<body>
    <div id="result"></div>
    <script>
        window.onkeydown = function() {
            const xhr = new XMLHttpRequest();
            xhr.responseType = 'json';
            xhr.open('GET', 'http://127.0.0.1:8000/json-server');
            xhr.send();
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4 && xhr.status >= 200 && xhr.status < 300) {
                    console.log(xhr.response);
                    result.innerHTML = xhr.response.name;
                }
            }
        }
    </script>
</body>
</html>
```


### 11. IE缓存问题解决
IE浏览器的缓存机制是：当从服务器获取过一次某个数据后，一段时间内，这个数据会存在ie的缓存中，用户想要再次获取该数据时，会优先使用缓存中的旧数据。如果服务器端数据已经更新过，此时数据便是错的，需要最新数据！！

以下是普通写法和针对IE缓存问题的写法对比：

普通写法：
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AJXA POST Request</title>
    <style>
        #result{
            width: 200px;
            height: 100px;
            border: solid 1px skyblue;
        }
    </style>
</head>
<body>
    <button>send request</button>
    <div id="result"></div>
    <script>
        const btn = document.getElementsByTagName('button')[0];
        const result = document.querySelector('#result');

        btn.addEventListener('click', function(){
            const xhr = new XMLHttpRequest();
            xhr.open('GET', 'http://127.0.0.1:8000/ie-cache');
            xhr.send();
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4 && xhr.status >= 200 && xhr.status < 300) {
                    result.innerHTML = xhr.response;
                }
            }
        })
    </script>
</body>
</html>
```

针对IE的写法：
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AJXA POST Request</title>
    <style>
        #result{
            width: 200px;
            height: 100px;
            border: solid 1px skyblue;
        }
    </style>
</head>
<body>
    <button>send request</button>
    <div id="result"></div>
    <script>
        const btn = document.getElementsByTagName('button')[0];
        const result = document.querySelector('#result');

        btn.addEventListener('click', function(){
            const xhr = new XMLHttpRequest();
            xhr.open('GET', 'http://127.0.0.1:8000/ie-cache?t='+Date.now());//增加时间戳，使IE浏览器认为这是两次不同的请求，因为URL每次都不一样
            xhr.send();
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4 && xhr.status >= 200 && xhr.status < 300) {
                    result.innerHTML = xhr.response;
                }
            }
        })
    </script>
</body>
</html>
```

后端：
```js
// 1. 引入express
const express = require('express');

// 2. 创建应用对象
const app = express();

// 3. 创建路由规则
// request 是对请求报文的封装
// reponse 是对响应报文的封装

app.all('/ie-cache', (request, response)=>{
    // 设置响应头: 允许跨域
    response.setHeader('Access-Control-Allow-Origin', '*');
    // 设置响应体
    response.send("IE-CACHE - 1");
});

// 4. 监听端口启动服务
app.listen(8000, ()=>{
    console.log("Server start, listening on 8000...");
});
```

### 12. AJAX请求的各种异常状态

##### 1. 请求超时
前端
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AJXA POST Request</title>
    <style>
        #result{
            width: 200px;
            height: 100px;
            border: solid 1px skyblue;
        }
    </style>
</head>
<body>
    <button>send request</button>
    <div id="result"></div>
    <script>
        const btn = document.getElementsByTagName('button')[0];
        const result = document.querySelector('#result');
        btn.addEventListener('click', function(){
            const xhr = new XMLHttpRequest();
            // 超时设置
            xhr.timeout = 2000;
            // 超时回调
            xhr.ontimeout = function() {
                alert("网络异常，请稍后重试！");
            }
            xhr.open("GET", 'http://127.0.0.1:8000/response-delay');
            xhr.send();
            xhr.onreadystatechange = function(){
                if (xhr.readyState === 4 && xhr.status >= 200 && xhr.status < 300) {
                    result.innerHTML = xhr.response;
                }
            }
        })
    </script>
</body>
</html>
```

后端
```js
// 1. 引入express
const express = require('express');

// 2. 创建应用对象
const app = express();  

// 3. 创建路由规则
// request 是对请求报文的封装
// reponse 是对响应报文的封装

// 延时响应
app.all('/response-delay', (request, response)=>{
    // 设置响应头: 允许跨域
    response.setHeader('Access-Control-Allow-Origin', '*');
    setTimeout(()=>{
        // 设置响应体
        response.send("response delay");
    }, 3000);
});

// 4. 监听端口启动服务
app.listen(8000, ()=>{
    console.log("Server start, listening on 8000...");
});
```

![[04.请求超时.png]]
##### 2. 网络异常
前端
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AJXA POST Request</title>
    <style>
        #result{
            width: 200px;
            height: 100px;
            border: solid 1px skyblue;
        }
    </style>
</head>
<body>
    <button>send request</button>
    <div id="result"></div>
    <script>
        const btn = document.getElementsByTagName('button')[0];
        const result = document.querySelector('#result');
        btn.addEventListener('click', function(){
            const xhr = new XMLHttpRequest();
            // 网络异常回调
            xhr.onerror = function() {
                alert("network error!");
            }
            xhr.open("GET", 'http://127.0.0.1:8000/response-delay');
            xhr.send();
            xhr.onreadystatechange = function(){
                if (xhr.readyState === 4 && xhr.status >= 200 && xhr.status < 300) {
                    result.innerHTML = xhr.response;
                }
            }
        })
    </script>
</body>
</html>
```
测试方法：Chrome浏览器断网方法
![[05.Chrome浏览器断网方法.png]]
##### 3. 取消请求
前端
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AJXA POST Request</title>
    <style>
        #result{
            width: 200px;
            height: 100px;
            border: solid 1px skyblue;
        }
    </style>
</head>
<body>
    <button>send request</button>
    <button>cancel request</button>
    <div id="result"></div>
    <script>
        const btns = document.getElementsByTagName('button');
        const result = document.querySelector('#result');
  
        let xhr = new XMLHttpRequest();

        // 发送请求
        btns[0].onclick = function() {
            xhr.open("GET", 'http://127.0.0.1:8000/response-delay');
            xhr.send();
        }
        // 取消请求
        btns[1].onclick = function() {
            xhr.abort();
        }
    </script>
</body>
</html>
```

##### 4. 请求重复发送
前端
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>repeat request</title>
    <style>
        #result{
            width: 200px;
            height: 100px;
            border: solid 1px skyblue;
        }
    </style>
</head>
<body>
    <button>send request</button>
    <div id="result"></div>
    <script>
        const btns = document.getElementsByTagName('button');
        const result = document.querySelector('#result');
  
        let xhr = null;
        let isSending = false;
        
        // 发送请求
        btns[0].onclick = function() {
            if (isSending) xhr.abort();
            xhr = new XMLHttpRequest();
            isSending = true;
            xhr.open("GET", 'http://127.0.0.1:8000/response-delay');
            xhr.send();
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                    isSending = false;
                }
            }
        }
    </script>
</body>
</html>
```